# vSIS PACS Reference Implementation

This repository packages the LVCS → PCS → PACS pipeline described in the SmallWood–ARK notes.  The prover follows the nine-round interactive outline (Fig. 7) and is Fiat–Shamir transformed with the grinding flow from the SHAKE diagram on p. 24.  We retain the chain-ℓ∞ membership gadget (`P, M, D₀, D₁`) so that each witness column is interpolated with degree bounded by `s + ℓ − 1`, matching the row-degree bound in Eq. (3).

## Transcript layout and Fiat–Shamir rounds

1. **Round 0** samples the salt with SHAKE-256 and grinds `Γ` until the digest has `κ₁` zero bits.  The prover commits to the masked witness polynomials and records `salt` and `ctr₁`.
2. **Round 1** grinds a second digest for `Γ′` (ρ batched Q-polynomials) with `κ₂` bits and stores `ctr₂` alongside `Γ′` and its polynomial encodings.
3. **Round 2** derives the ℓ′ evaluation queries `E′` together with the LVCS coefficient matrix using `κ₃` bits of grinding.  The proof stores the evaluation points and all `{v_k^{(e′)}, \bar v_k^{(e′)}}` combinations.
4. **Round 3** grinds `E ⊂ [N]` (size ℓ) with `κ₄` bits and opens the DECS commitments on both the masked indices and the challenge set.  The proof embeds `ctr₄`, `E`, and the Merkle-authenticated openings.

The compressed transcript therefore contains

- `salt`, `ctr₁..ctr₄`;
- the matrices `Γ`, `Γ′`, `Γ′_agg` and their byte serialisations;
- evaluation points `E′`, tail indices `E`, LVCS requests, masked values, and Merkle openings;
- the batched mask polynomials `M[0..ρ−1]` and the `Q_i` polynomials in NTT form.

`Proof.Snapshot()` reduces these objects to plain slices so they can be serialised to JSON and later restored via `ProofSnapshot.Restore` using the target ring.

## Security knobs (Table 1 mapping)

| Symbol | CLI flag | Default | Description |
|--------|----------|---------|-------------|
| `s` | `--ncols` | 8 | number of evaluation columns in Ω |
| `ℓ` | `--ell` | 64 | masked positions opened per DECS repetition |
| `ℓ′` | `--ellp` | 8 | LVCS/PIOP evaluation queries |
| `ρ` | `--rho` | 8 | parallel batches of Q-polynomials |
| `η` | `--eta` | 3 | DECS degree-enforcing repetitions |
| `N` | `--nleaves` | 2¹⁸ | Merkle leaf count |
| `θ` | `--theta` | 1 | extension degree in the PCS layout |
| `d_Q` | `--dq` | 0 (auto) | override for the row-degree bound in Eq. (3) |
| `κ₁..κ₄` | `--kappa1..4` | 16 | grinding slack for the four FS rounds |
| `λ` | `--lambda` | 128 | Fiat–Shamir security target |

All CLI entry points (`ntrucli pacs`, `cmd/pacs_sweep`) thread these options through `SimOpts`, so the prover and verifier consume identical knobs throughout the transcript.

## Command-Line Tooling

Refer to `docs/CLI.md` for a detailed description of the executables under `cmd/`, their flags, and how they compose the NTRU, LVCS/DECS, and PACS layers. `Commands.md` provides quick invocation examples.

## Soundness accounting (Eq. (8))

For field size `q`, the implementation computes the four error terms exactly as in Eq. (8):

- `ε₁ = (N / (d_decs + 2)) / q^{η}` from the DECS degree check,
- `ε₂ = q^{−ρ}` from the batched Q-polynomials,
- `ε₃ = (d_Q / q)^{ℓ′}` from the Schwartz–Zippel bound,
- `ε₄ = (\binom{s + ℓ − 1}{ℓ} / \binom{N}{ℓ})` from the Merkle openings.

Grinding contributes slack terms `2^{-(λ - κ_i)}` for each Fiat–Shamir round; the log output therefore lists `ε₁..ε₄`, the four grinding bits, and the combined union bound `ε_total`.  Row and query counts follow the PCS shape in Eq. (10):

```
nrows = ceil(n / s) · (s + θ) + ceil(d_Q / s) · θ
m     = (ceil(n / s) + 1) · θ
```

These values, together with `d_Q`, are attached to every `SimReport` and appear in the CSV generated by `cmd/pacs_sweep`.

## CLI cheatsheet

```
go run ./cmd/ntrucli pacs \
  --rho=8 --ellp=8 --ell=64 --eta=3 --nleaves=262144 \
  --kappa1=16 --kappa2=16 --kappa3=16 --kappa4=16
```

The sweep tool accepts grids for each knob and emits `rho,ellp,eta,NLeaves,kappa1..4,dq_override,degree,rows_committed,m,proof_bytes,eps*_bits,eps_total_bits,eps_total` so parameter searches can be reconciled with Table 2 and Eq. (10).

## Proof checks

`checkEq4OnOpening` now evaluates Eq. (4) on both the masked coordinates (Ω ∪ Ω′) and every evaluation point `e ∈ E′`.  `EvalInitMany` batches ℓ′ LVCS queries so the verifier replays the full set of masked linear relations when recomputing `{v_k^{(e′)}, \bar v_k^{(e′)}}`.  Tampering with either `Γ′` or the evaluation responses causes the Eq. (4) check to fail, as exercised by `TestPIOP_MultiBatch_MultiEval_Rejects`.

## Proof payload shaping

Recent iterations shrank the heaviest DECS openings while keeping the prover/verifier flow unchanged:

- **Tail index packing** – Mask prefixes keep describing contiguous ranges, but the explicit tail section is now emitted as a 13-bit stream (`IndexBits`).  The packing triggers automatically when every index fits below `2¹³`, cutting the per-index footprint from ~2.0 bytes (LEB128 varints) to 1.5 bytes.  The decoder rebuilds the mixed mask+tail view transparently via `DECSOpening.IndexAt`/`AllIndices`.
- **Merkle path bit packing** – The old `PathIndexVar` array of per-level varints was replaced by `PathBits`, a fixed-width bitstream whose width is derived from the largest sibling identifier.  When a frontier needs to be expanded, the verifier materialises a dense path matrix in-place; otherwise, the packed form is preserved across snapshots and round-trips.  `EnsureMerkleDecoded` understands both the packed and unpacked representations, so legacy callers keep functioning with no changes.
- **Merkle frontier union** – Frontier siblings are now deduplicated.  The prover only serialises unique 16-byte hashes in `FrontierNodes` and records, in a compact reference stream, which union index each proof step consumes.  The verifier replays the same union directly, which reduces payload when several leaves share identical siblings (a common pattern in structured openings).
- **Adaptive numeric packing** – The shared matrix codec now emits a 10-byte header (rows/cols/bit width) followed by a fixed-width payload.  `MR`, `BarSets`, and `VTargets` automatically drop to 16-bit streams when coefficients fit inside `2¹⁶`, falling back to 20-bit (or wider) otherwise.  Snapshots, size accounting, and the PACS sweep tooling consume the packed form, so the new savings are reflected in every report.
- **Metrics instrumentation** – Setting `DEBUG_DECS_OPENINGS=1` now prints an itemised byte breakdown showing how much of each opening is spent on indices, packed residues, Merkle data, and nonce material.  The logger highlights whether paths/tails are compressed (and their meta bytes) to make regression tracking easier during future optimisations.

These changes affect both the prover and the verifier:

- Prover-side packers (`DECS/decs_prover.go`) emit the new bitstreams and clear the redundant slices so snapshots stay small.
- Verifier helpers (`DECS/decs_verifier.go`, `PIOP/VerifyNIZK.go`, `LVCS/lvcs_verifier.go`) call `EnsureMerkleDecoded` whenever an explicit Merkle path is required, ensuring the packed form is understood in every check.
- Snapshot logic, proof cloning, and the PACS simulation tests were refreshed so that round-trip comparisons include the new `PathBits` metadata alongside the residue bitstreams.

### Next optimisation targets

With tail indices and path tables trimmed, the remaining payload hotspots are:

1. **Snapshot/tooling refinements** – With the new matrix codec in place, extend `MeasureProofSize`, `cmd/pacs_sweep`, and any bespoke exporters to surface the recorded bit widths so downstream tooling can compare 16-bit vs 20-bit runs side by side.
2. **Gadget sharing & packing heuristics** – Now that the Merkle frontier is deduped, review whether mask/tail openings can share node tables or reuse previously packed rows when both openings reference the same siblings.
3. **Legacy cleanup & compatibility flag** – Once the new encodings have shipped in a compatibility window, prune the redundant 20-bit-only paths and strip any unused snapshot fields so the serializer stays lean.

Each of these steps builds upon the current packing primitives, keeping prover/verifier symmetry explicit while shaving the remaining kilobytes from the Row/M openings.

## Chain-ℓ∞ gadget

The only norm path retained is the membership-chain gadget (`M, D₀, D₁`).  Digit checks are evaluated on Ω prior to interpolation, keeping the row degree near `s + ℓ − 1` and aligning with the “parallel vs. aggregated” split in the slides (pp. 9–12).  This ensures the PCS layer benefits from the small-field interpolation described in §4–§5 while avoiding the legacy slack/outlier counters.  The gadget operates with a fixed 7-bit window (R = 128) and caps the infinite-norm budget at β∞ = 6000.

## Tests

- `TestPIOP_MultiEval_MultiBatch` covers multi-batch, multi-query runs and confirms all verifier checks succeed.
- `TestPIOP_MultiBatch_MultiEval_Rejects` forges a Q coefficient and observes Eq. (4) failing over both Ω and `E′`.
- `TestLVCS_EvalInitManyRoundTrip` validates LVCS batching and explicit `Γ` injection.
- `TestProofSerialization` snapshots a full proof, restores it, and compares salt, counters, and challenges.
- `TestPIOP_SoundnessKnobs` logs the impact of shrinking `ρ`, `ℓ′`, `ℓ`, `η`, and `κ_i` on the union bound to diagnose security margins.

Together with the log output, these checks demonstrate that the implementation follows Theorem 3–7, Eq. (3)/(8)/(10), and the nine-round Fiat–Shamir schedule in Fig. 7.
